Основная задача Docker это запуск приложения.

    Он был создан для того, чтобы разработчики не занимались настройкой, на удалённом сервере пакетов и их зависимостей,
а развернул всё из под Docker контейнера. Как пример, вам надо развернуть тестовую базу данных, например MongoDB,
нам нужна только база данных и всё, нам не нужно развёртывать это всё на VM, т.к. это очень ресурсозатратно,
или представим, что у нас микросервисная архитектура и у нас их порядком 50 или
больше, никакое железо не потянет столько VM. Хотелось бы найти более подходящее решение, сэкономить на ресурсах, но в
тоже время и задачу решить. Из этого следует:
    - Отсутствие единого механизма разворачивания приложений, т.е. все приложения разные, пишутся на разных языках и
      требуют своего подхода;
    - Отсутствие единого механизма передачи готового приложения;
    - Отсутствие единого механизма сборки системы из приложений.

    Принцип работы Docker в том, что берётся приложение, запаковывается в некий контейнер, в этот контейнер мы кладём все
необходимые пакеты и зависимости с определёнными версиями, создадим окружение необходимое для этого приложения
(все системные переменные, т.е. всё что нужно), полностью всё упакуем, для этого будем использовать одно ядро, т.е.
общий корабль для всех контейнеров, и это всё изолируем, сделаем единый механизм запуска
и эти контейнеры мы будем запускать.
    Docker - это средство упаковки, доставки и запуска приложений.

    Упаковка - мы упаковываем всё что нам надо в один контейнер, как в посылку.
    Доставка - каким-то образом Docker  предлагает нам этот контейнер (посылку, сущность, которую мы запоковали)
               передать каким-то образом.
    Запуск - каким-то образом Docker предлагает нам все, что мы передали запустить.

    У всех стадий есть единый унифицированный интерфейс. Если я упаковал приложение на Python, а кто-то на Java,
то запуск этих приложений, точнее контейнеров будет один и тотже.

    В Docker есть два основных понятия это Docker image и Docker container.
        Docker image - эта наша сборка, т.е готовое к запуску приложение, но ещё не запущеное.
        Docker container - это работающее приложение, созданное на базе Docker image.

    Другими словами, когда мы упаковали приложение мы можем на основе этого упакованного Docker image
    (далее - образ) создать кучу одинаковых Docker container (далее - контейнер).

    Например это могут быть десять реплик одного и тогоже web сервиса из одного образа.
    Для контейнера образ является readonly системой, он никаким образом не может его изменить, т.е. когда запускается
на основе образа контейнер и внутри контейнера я выполняю команду на удаление всех данных, все данные действительно
удалятся, только они удалятся в рамках контейнера, на образ это никак не повлияет, я могу остановить контейнер удалить
его и на основе образа создать новый контейнер и он опять будет прекрасно работать выполнять какие-то операции,
на образ это никак не повлияет. Получается контейнер это наше работающее приложение и контейнер создаётся на основе
образа.
    Образ представляется некой структурой напоминающий слоёный пирог.  Например есть у нас образ Ubuntu, голая
установленная опреационка, делаем её первым слоем. Ничего не мешает нам создать контейнер на основе этого образа
с одним слоем, установленной ОС Ubuntu, и запустить его. Мы берём данный образ за базу и поверх устанавливаем Nginx, у
нас уже получился другой образ с Nginx. Теперь мы например берём первый образ с установленной Ubuntu и устанавливаем
MongoDB, т.о. мы получили третий образ с установленной MongoDB, или мы берём за основу образ с Ubuntu, и устанавливаем
поверх Python, т.о. получаем четвёртый образ и после этого берём образ с Python и ставим наше приложение, т.о. получаем
пятый образ.
Если я разаработчик и пишу приложение на Python и я хочу запустить моё приложение в Docker, я вижу всё многообразие
образов и у меня есть несколько вариантов:
        * Первый взять готовый образ с Python, т.е. Ubuntu и Python, поверх его наложить ещё один слой с нашим
          приложением и на основании этого готового образа создать контейнер и запустить его.
        * Второй вариант мы берём образ с Ubuntu, сделать свой собственный слой с Python, если нам это надо и поверх
          этого слоя поставить наше приложение и на основании уже этого готового образа создать контейнер
          и запустить его.

    Другими словами образы представляют собой, как бы многослойную систему (как слоёный пирог), которую мы можем пополнять
новыми слоями.

    Реестр образов (Docker registry), из которых мы можем выбрать нужный нам образ находятся в локальном репозитории,
там находятся образы которые создали мы сами или загрузили, например с Docker hub.
    Docker hub - представляет собой реестр образов Docker images, где есть образы которые поддерживаются разработчиками
Docker. а есть образы которые поддерживаются самими людьми (пользователями), вы можете там зарегистрироваться и хранить
созданные нами образы.
    Если подитожить, у Docker есть единый механизм сборки приложений - это сами образы (Docker images), т.е. мы
определённым образом с помощью каких-то команд можем создать свой образ и на его основе создать и запустить контейнер,
другими словами, у Docker есть единый механизм запуска приложений.
     Созданные образы мы можем отправить на Docker hub, а от туда брать уже на продакшн сервере загружать и исполнять,
т.о. у Docker есть единый механизм доставки этих образов (приложений).
для Docker устанавливается GUI но с ним очень удобно работать через терминал.

            Установка Docker.
    Вбиваем в поисковой системе браузера "docker desktop", переходим на сайт "https://www.docker.com/" где есть
установщики Docker для Mac и Windows, под Linux через apt.


Смотрим, какие есть в системе Docker Img:
    > sudo docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE

Смотрим какие в системе есть контейнеры:
    >sudo docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

Пока в системе нет ни образов ни контейнеров.

Переходим в текущую папку:
        admin1@ubuntu18:~$ cd work
        admin1@ubuntu18:~/work$ cd Education
        admin1@ubuntu18:~/work/Education$ cd Docker
        admin1@ubuntu18:~/work/Education/Docker$ cd EducateDocker
        admin1@ubuntu18:~/work/Education/Docker/EducateDocker$

Пытаемся собрать свой образ с запуском приложения (скрипта) "app.py".

    sudo docker build -t hello-world
        * Первый параметр '-t' - тэг, определяющий имя нашего новый образа (hello-world);
        * Второй параметр - директория, из которой мы будем собирать своё приложение, в нашем случае '.', т.е.
          текущая директория;

При выполнении получаем ошибку:

    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker build -t hello-world .
    [sudo] пароль для admin1:
    unable to prepare context: unable to evaluate symlinks in Dockerfile path: lstat
    /home/admin1/work/Education/Docker/EducateDocker/Dockerfile: no such file or directory

    Не удалось найти Dockerfile.
    Docker не понимает что ему необходимо сделать, поэтому нам необходимо сказать как имено нужно упаковать наше
приложение, т.к. проиложения бывают разные, одни написанны на Java другие например на Go и т.д., есть различные
механизмы запуска и это всё каким то образом необходимо сообщить Docker. Для этих целей и существует DockerFile, пишется
как есть без расширений. Создадим в папке приложения файл DockerFile. И отредактируем его:

        # Базовый образ с которого мы начинаем сборку.
        # Базовых образов очень много (Ubuntu, nginx и т.д.), т.к. у нас приложение интерпретируется в Python, то мы
        # базовый образ у нас это python:3.6, через двоеточие ':' здесь указывается версия.
            FROM python:3.6
        # Здесь мы выполняем команду, RUN определяет, что мы должны выполнить определённую команду, которая идёт за RUN, т.е.
        # создание папки
            RUN mkdir -p /usr/src/app/
        # Переходим в этот каталог (рабочий каталог приложения), т.е. мы создали папку и перешли в неё.
            WORKDIR /usr/src/app/
        # Копирование откуда (с нашей машины, с текущей директории) куда (в образ, в созданную ранее папку)
            COPY . /usr/src/app/

        # Что нужно делать, когда мы запустим контейнер
        # Здесь нужно выполнить команду python app.py
        # есть разница между командами CMD и ENTRYPOINT, по сути они выполняют похожие действия, т.е.
        # команда ENTRYPOINT ["python", "app.py"] будет выполнятся не в консоли (shell), а CMD в консоли (shell)
            CMD ["python", "app.py"]


