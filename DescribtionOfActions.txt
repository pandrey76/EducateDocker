Основная задача Docker это запуск приложения.

    Он был создан для того, чтобы разработчики не занимались настройкой, на удалённом сервере пакетов и их зависимостей,
а развернул всё из под Docker контейнера. Как пример, вам надо развернуть тестовую базу данных, например MongoDB,
нам нужна только база данных и всё, нам не нужно развёртывать это всё на VM, т.к. это очень ресурсозатратно,
или представим, что у нас микросервисная архитектура и у нас их порядком 50 или
больше, никакое железо не потянет столько VM. Хотелось бы найти более подходящее решение, сэкономить на ресурсах, но в
тоже время и задачу решить. Из этого следует:
    - Отсутствие единого механизма разворачивания приложений, т.е. все приложения разные, пишутся на разных языках и
      требуют своего подхода;
    - Отсутствие единого механизма передачи готового приложения;
    - Отсутствие единого механизма сборки системы из приложений.

    Принцип работы Docker в том, что берётся приложение, запаковывается в некий контейнер, в этот контейнер мы кладём все
необходимые пакеты и зависимости с определёнными версиями, создадим окружение необходимое для этого приложения
(все системные переменные, т.е. всё что нужно), полностью всё упакуем, для этого будем использовать одно ядро, т.е.
общий корабль для всех контейнеров, и это всё изолируем, сделаем единый механизм запуска
и эти контейнеры мы будем запускать.
    Docker - это средство упаковки, доставки и запуска приложений.

    Упаковка - мы упаковываем всё что нам надо в один контейнер, как в посылку.
    Доставка - каким-то образом Docker  предлагает нам этот контейнер (посылку, сущность, которую мы запоковали)
               передать каким-то образом.
    Запуск - каким-то образом Docker предлагает нам все, что мы передали запустить.

    У всех стадий есть единый унифицированный интерфейс. Если я упаковал приложение на Python, а кто-то на Java,
то запуск этих приложений, точнее контейнеров будет один и тотже.

    В Docker есть два основных понятия это Docker image и Docker container.
        Docker image - эта наша сборка, т.е готовое к запуску приложение, но ещё не запущеное.
        Docker container - это работающее приложение, созданное на базе Docker image.

    Другими словами, когда мы упаковали приложение мы можем на основе этого упакованного Docker image
    (далее - образ) создать кучу одинаковых Docker container (далее - контейнер).

    Например это могут быть десять реплик одного и тогоже web сервиса из одного образа.
    Для контейнера образ является readonly системой, он никаким образом не может его изменить, т.е. когда запускается
на основе образа контейнер и внутри контейнера я выполняю команду на удаление всех данных, все данные действительно
удалятся, только они удалятся в рамках контейнера, на образ это никак не повлияет, я могу остановить контейнер удалить
его и на основе образа создать новый контейнер и он опять будет прекрасно работать выполнять какие-то операции,
на образ это никак не повлияет. Получается контейнер это наше работающее приложение и контейнер создаётся на основе
образа.
    Образ представляется некой структурой напоминающий слоёный пирог.  Например есть у нас образ Ubuntu, голая
установленная опреационка, делаем её первым слоем. Ничего не мешает нам создать контейнер на основе этого образа
с одним слоем, установленной ОС Ubuntu, и запустить его. Мы берём данный образ за базу и поверх устанавливаем Nginx, у
нас уже получился другой образ с Nginx. Теперь мы например берём первый образ с установленной Ubuntu и устанавливаем
MongoDB, т.о. мы получили третий образ с установленной MongoDB, или мы берём за основу образ с Ubuntu, и устанавливаем
поверх Python, т.о. получаем четвёртый образ и после этого берём образ с Python и ставим наше приложение, т.о. получаем
пятый образ.
Если я разаработчик и пишу приложение на Python и я хочу запустить моё приложение в Docker, я вижу всё многообразие
образов и у меня есть несколько вариантов:
        * Первый взять готовый образ с Python, т.е. Ubuntu и Python, поверх его наложить ещё один слой с нашим
          приложением и на основании этого готового образа создать контейнер и запустить его.
        * Второй вариант мы берём образ с Ubuntu, сделать свой собственный слой с Python, если нам это надо и поверх
          этого слоя поставить наше приложение и на основании уже этого готового образа создать контейнер
          и запустить его.

    Другими словами образы представляют собой, как бы многослойную систему (как слоёный пирог), которую мы можем пополнять
новыми слоями.

    Реестр образов (Docker registry), из которых мы можем выбрать нужный нам образ находятся в локальном репозитории,
там находятся образы которые создали мы сами или загрузили, например с Docker hub.
    Docker hub - представляет собой реестр образов Docker images, где есть образы которые поддерживаются разработчиками
Docker. а есть образы которые поддерживаются самими людьми (пользователями), вы можете там зарегистрироваться и хранить
созданные нами образы.
    Если подитожить, у Docker есть единый механизм сборки приложений - это сами образы (Docker images), т.е. мы
определённым образом с помощью каких-то команд можем создать свой образ и на его основе создать и запустить контейнер,
другими словами, у Docker есть единый механизм запуска приложений.
     Созданные образы мы можем отправить на Docker hub, а от туда брать уже на продакшн сервере загружать и исполнять,
т.о. у Docker есть единый механизм доставки этих образов (приложений).
для Docker устанавливается GUI но с ним очень удобно работать через терминал.

            Установка Docker.
    Вбиваем в поисковой системе браузера "docker desktop", переходим на сайт "https://www.docker.com/" где есть
установщики Docker для Mac и Windows, под Linux через apt.


Смотрим, какие есть в системе Docker Img:
    > sudo docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE

Смотрим какие в системе есть контейнеры:
    >sudo docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

Пока в системе нет ни образов ни контейнеров.

Переходим в текущую папку:
        admin1@ubuntu18:~$ cd work
        admin1@ubuntu18:~/work$ cd Education
        admin1@ubuntu18:~/work/Education$ cd Docker
        admin1@ubuntu18:~/work/Education/Docker$ cd EducateDocker
        admin1@ubuntu18:~/work/Education/Docker/EducateDocker$

Ссоздаём приложения (скрипта) "app.py", следующего содержания:

    print("Hello, world!")

Пытаемся собрать свой образ с запуском приложения (скрипта) "app.py".

    sudo docker build -t hello-world
        * Первый параметр '-t' - тэг, определяющий имя нашего новый образа (hello-world);
        * Второй параметр - директория, из которой мы будем собирать своё приложение, в нашем случае '.', т.е.
          текущая директория;

При выполнении получаем ошибку:

    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker build -t hello-world .
    [sudo] пароль для admin1:
    unable to prepare context: unable to evaluate symlinks in Dockerfile path: lstat
    /home/admin1/work/Education/Docker/EducateDocker/Dockerfile: no such file or directory

    Не удалось найти Dockerfile.
    Docker не понимает что ему необходимо сделать, поэтому нам необходимо сказать как имено нужно упаковать наше
приложение, т.к. проиложения бывают разные, одни написанны на Java другие например на Go и т.д., есть различные
механизмы запуска и это всё каким то образом необходимо сообщить Docker. Для этих целей и существует DockerFile, пишется
как есть без расширений. Создадим в папке приложения файл DockerFile. И отредактируем его:

        # Базовый образ с которого мы начинаем сборку.
        # Базовых образов очень много (Ubuntu, nginx и т.д.), т.к. у нас приложение интерпретируется в Python, то мы
        # базовый образ у нас это python:3.6, через двоеточие ':' здесь указывается версия.
            FROM python:3.6
        # Здесь мы выполняем команду, RUN определяет, что мы должны выполнить определённую команду, которая идёт за RUN, т.е.
        # создание папки
            RUN mkdir -p /usr/src/app/
        # Переходим в этот каталог (рабочий каталог приложения), т.е. мы создали папку и перешли в неё.
            WORKDIR /usr/src/app/
        # Копирование откуда (с нашей машины, с текущей директории) куда (в образ, в созданную ранее папку)
            COPY . /usr/src/app/

        # Что нужно делать, когда мы запустим контейнер
        # Здесь нужно выполнить команду python app.py
        # есть разница между командами CMD и ENTRYPOINT, по сути они выполняют похожие действия, т.е.
        # команда ENTRYPOINT ["python", "app.py"] будет выполнятся не в консоли (shell), а CMD в консоли (shell)
            CMD ["python", "app.py"]


Теперь пытаемся собрать свой образ:
    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker build -t hello-world .
    [sudo] пароль для admin1:

    Сейчас наблюдаем загрузку базового образа, который мы выбрали Python: 3.6, т.е. Docker посмотрел, что мы начинаем
сборку с образа Python 3.6, но локально такого образа нет, тогда Docker пошёл в Docker hub, посмотрел есть ли там такой
образ, нашёл его и начал его скачивать.

    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker build -t hello-world .
    [sudo] пароль для admin1:
    Sending build context to Docker daemon  114.2kB
    Step 1/5 : FROM python:3.6
    3.6: Pulling from library/python
    50e431f79093: Pull complete
    dd8c6d374ea5: Pull complete
    c85513200d84: Pull complete
    55769680e827: Pull complete
    f5e195d50b88: Pull complete
    bcd75869ea17: Pull complete
    f02a073bb16c: Pull complete
    d317a9591eb3: Pull complete
    579334b3a1fd: Pull complete
    Digest: sha256:0b6aeeb47c4a5e0051bb41c7a7f300b69e68af873081f8f2f7fbcd8d5c47e264
    Status: Downloaded newer image for python:3.6
    ---> 1daf62e8cab5
    Step 2/5 : RUN mkdir -p /usr/src/app/
    ---> Running in 23275ff5b129
    Removing intermediate container 23275ff5b129
    ---> 6cb89215e9cd
    Step 3/5 : WORKDIR /usr/src/app/
    ---> Running in 9fb8ebb4a713
    Removing intermediate container 9fb8ebb4a713
    ---> 0b2f81f3ae24
    Step 4/5 : COPY . /usr/src/app/
    ---> fd5bce5802e1
    Step 5/5 : CMD ["python", "app.py"]
    ---> Running in 9521b98b28b0
    Removing intermediate container 9521b98b28b0
    ---> 3d1be4c548b1
    Successfully built 3d1be4c548b1
    Successfully tagged hello-world:latest

    Мы сдесь наблюдаем много различных слоёв, сам базовый образ Python 3.6, состаит из 9 слёв (Образ Ubuntu,
apt install python и т.д.). Каждая команда в Dockerfile создаёт свой слой, поверх базовых слоёв образа Python 3.6.

    Теперь посмотрим какие образы есть в систнме:

    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker images
    [sudo] пароль для admin1:
    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
    hello-world         latest              3d1be4c548b1        13 minutes ago      914MB
    python              3.6                 1daf62e8cab5        12 days ago         914MB

    Мы видим, что у нас есть два образа python 3.6 и hello-world. IMAGE ID - это контрольная сумма образа sha256.

    Теперь запускаем наш образ:

    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker run hello-world
    Hello, world!

    Мы видим, что контейнер запустился и выполнился, наше приложение корректно отработало. Контейнер работает до тех
пор пока работает приложение.

    Выполним команду:

    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker ps
    CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

    Мы видим, что у нас нет контейнеров, дело в том, что контейнер уже отработал и остановился, т.к. у нас очень
простое приложение, только вывести Hello, world!, но он не исчез, поэтому, чтобы посмотреть все контейнеры, даже
которые уже остановились надо выполнить команду:

    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker ps -a
    CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
    ec3dc4f9af26        hello-world         "python app.py"     11 minutes ago      Exited (0) 11 minutes ago                       elegant_haslett

    Видим идентификатор контейнера, его sha256 (CONTAINER ID), из образа с именем 'hello-world' (IMAGE), команда "python app.py"
(COMMAND), статус выполненные с кодом возврата "0" (STATUS) всё хорошо у нас отработало.
    Имя у нашего контейнера "elegant_haslett", если мы сами не указываем имя контейнера при его запуске, то Docker
сам выбирает ему имя. Мы можем задать своё имя:

    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker run --name hello hello-world
    Hello, world!
    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker ps -a
    CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
    1c17b92520ac        hello-world         "python app.py"     34 seconds ago      Exited (0) 32 seconds ago                       hello
    ec3dc4f9af26        hello-world         "python app.py"     21 minutes ago      Exited (0) 21 minutes ago                       elegant_haslett

    Здесь мы видим, что у нас уже в системе есть два контейнера, второй который мы только, что создали.
    Как нам теперь удалить контейнеры с помощью команды "docker rm" в качестве параметра можно передать или
идентификатор контейнера (CONTAINER ID) или имя (NAMES).

    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker rm 1c17b92520ac
    1c17b92520ac
    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker ps -a
    CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
    ec3dc4f9af26        hello-world         "python app.py"     39 minutes ago      Exited (0) 39 minutes ago                       elegant_haslett

    Мы видим, что один контейнер был удалён из системы, а если у нас этих контейнеров 50, то будет не очень удобно их
по одному в ручную останавливать (удалять). Для этого, Мы можем добавить ещё одну команду в "docker ps" "-q", которая
выводит только (CONTAINER ID).

    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker ps -a -q
    ec3dc4f9af26

    Теперь вывод этой команды мы можем передать команде "docker rm"

    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker rm $(sudo docker ps -qa)
    ec3dc4f9af26
    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker ps -a
    CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

    Мы видим, что мы удалили из ситсемы все контейнеры.

    Теперь отредактируем файл app.py:

        import time
        while True:
            print("Hello, world!")
            # Задержка на 1 секутду
            time.sleep(1)

    Собираем наш новый образ:

        admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker build -t hello-world .
        [sudo] пароль для admin1:
        Sending build context to Docker daemon  142.8kB
        Step 1/5 : FROM python:3.6
        ---> 1daf62e8cab5
        Step 2/5 : RUN mkdir -p /usr/src/app/
        ---> Using cache
        ---> 6cb89215e9cd
        Step 3/5 : WORKDIR /usr/src/app/
        ---> Using cache
        ---> 0b2f81f3ae24
        Step 4/5 : COPY . /usr/src/app/
        ---> 4709754f91a6
        Step 5/5 : CMD ["python", "app.py"]
        ---> Running in 90b705195ae2
        Removing intermediate container 90b705195ae2
        ---> ea3e8c3f2f44
        Successfully built ea3e8c3f2f44
        Successfully tagged hello-world:latest

    Здесь мы видим, что скачивание базового образа (python 3.6) не происходит, он берётся из локального хранилища.
Если мы сейчас запустим контейнер (sudo docker run --name hello hello-world), то ткрминал у нас будет занят, т.к.
наше приложение выполняется в бесконечном цикле, мы не сможем выполнять другие команды в терминале. Для  того чтобы
запустить контейнер в фоне есть параметр "-d". При использовании этого параметра контейнер запустится в фоне, в
нашем случае бесконечный вывод сообщения "Hello, world!":

        admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker run --name hello -d hello-world
        d0e254c23304c7b97bf9d61b79fd6788b30aeafb13ed9d63b77adad7faaf9a6a

        admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
        d0e254c23304        hello-world         "python app.py"     45 seconds ago      Up 44 seconds                           hello

    Мы видим, что у нас один контейнер в статусе запушен (Up) 44 секунды назад с именем hello. Мы можем этот контейнер
остановить, командой "stop" передав или Имя контейнера или его Идентификатор контейнера, не Имя образа!!!:

        admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker stop hello
        hello
        admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

    Мы видим, что никаких контейнеров нет.

        admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker ps -a
        CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                        PORTS               NAMES
        d0e254c23304        hello-world         "python app.py"     6 minutes ago       Exited (137) 51 seconds ago                       hello

    Список всех контейнеров, и наш ко статусов завершён (Exited) 51 секунду назад. Код возврата не "0", а 137, т.к.
мы принудительно остановили контейнер.
    Теперь удалим наш контейнер:

        admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker rm hello
        hello
    А если нам нужно сделать так, чтобы контейнер, после того как он отработает или мы его завершим, сам удалился,
чтобы не выполнять самим дополнительные команды в терминале (sudo docker rm hello и т.д.) необходимо добавить
команду "--rm". Теперь получается после того как котейнер либо отработает, либо мы его остановим он сам удалится:

        admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker run --name hello -d --rm hello-world
        602fe94114a97b5640795f211ef27f78dbb9806009aac341e0b4201a471dee9b

        admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
        602fe94114a9        hello-world         "python app.py"     3 minutes ago       Up 3 minutes                            hello

        admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker stop hello
        hello

        admin1@ubuntu18:~/work/Education/Docker/EducateDocker$  sudo docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
        admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ sudo docker ps -a
        CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

    Мы видим, что в системе нет никаких контейнеров.

    Подитожим, у нас есть Docker образы, на базе которых создаются контейнеры. Для того, чтобы создать свой
собсвенный Docker образ нам нужно прописать в Dockerfile все необходимые команды, в каждом конкретном случае это будут
какие-то свои, определённые команды. Далее необходимо выполнить команду "docker build" и далее "docker run".


************************************************************************************************************************
        Web приложения.
************************************************************************************************************************

       Папка Web-hello-world.

      Файл app.py
************************************************************************************************************************

        import os
        import json
        import datetime
        from flask import Flask

        app = Flask(__name__)

        BASE_FOLDER = os.path.dirname(os.path.abspath(__file__))
        RESOURCE_DIR = os.path.join(BASE_FOLDER, "resources")

        # когда мы в браузере открываем страницу, то у нас открывается файл "response.json" и от туда достаётся содержимое
        # поля "payload", добавляется дата текущая и как строка возвращается пользователю.

        @app.route('/')
        def hello_world():
            with open(os.path.join(RESOURCE_DIR, "response.json")) as f:
                return "%s - %s" % (json.loads(f.read()).get("payload"), datetime.datetime.now().strftime("%d.%m.%Y %H:%M:%S"))


        if __name__ == "__main__":
            app.run(host="0.0.0.0", port=8080, debug=True)

************************************************************************************************************************

       Папка Web-hello-world/resources.

      Файл response.json
************************************************************************************************************************

{
    "payload": "This is string..."
}

************************************************************************************************************************

    Настраиваем виртуальное окружение.
    admin1@ubuntu18:~/work/Education/Docker/EducateDocker$ cd Web-hello-world
    admin1@ubuntu18:~/work/Education/Docker/EducateDocker/Web-hello-world$ virtualenv WebHelloWorldEnv
        Using base prefix '/usr'
        New python executable in /home/admin1/work/Education/Docker/EducateDocker/Web-hello-world/WebHelloWorldEnv/bin/python3
        Also creating executable in /home/admin1/work/Education/Docker/EducateDocker/Web-hello-world/WebHelloWorldEnv/bin/python
        Installing setuptools, pip, wheel...
        done.
    admin1@ubuntu18:~/work/Education/Docker/EducateDocker/Web-hello-world$ cd WebHelloWorldEnv
    admin1@ubuntu18:~/work/Education/Docker/EducateDocker/Web-hello-world/WebHelloWorldEnv$ cd bin
    admin1@ubuntu18:~/work/Education/Docker/EducateDocker/Web-hello-world/WebHelloWorldEnv/bin$ . activate
    (WebHelloWorldEnv) admin1@ubuntu18:~/work/Education/Docker/EducateDocker/Web-hello-world/WebHelloWorldEnv/bin$

    Запускаем app.py:

        /usr/bin/python3.6 /home/admin1/work/Education/Docker/EducateDocker/Web-hello-world/app.py
        * Running on http://0.0.0.0:8080/ (Press CTRL+C to quit)
        * Restarting with stat
        * Debugger is active!
        * Debugger PIN: 533-910-208

     В браузере вводим строку "http://0.0.0.0:8080/" И видим параметр "payload" из файла "response.json" и текущую дату:

            This is string... - 11.03.2020 17:37:57

     Меняем "payload": "This is string..." в файле "response.json" на "payload": "hello, world!" и в браузере получаем:

            Hello, world! - 11.03.2020 17:45:14

    Далее будем упаковывать это Web приложение в Docker образ. Для его работы нам необходимы зависимости, а имено Flask,
данная зависимость устанавливается с помощью утилиты pip
        pip install flask

        (WebHelloWorldEnv) admin1@ubuntu18:~/work/Education/Docker/EducateDocker/Web-hello-world$ pip install flask
            Collecting flask
                Downloading Flask-1.1.1-py2.py3-none-any.whl (94 kB)
                    |████████████████████████████████| 94 kB 362 kB/s
            Collecting Jinja2>=2.10.1
                Downloading Jinja2-2.11.1-py2.py3-none-any.whl (126 kB)
                    |████████████████████████████████| 126 kB 803 kB/s
            Collecting itsdangerous>=0.24
                Downloading itsdangerous-1.1.0-py2.py3-none-any.whl (16 kB)
            Collecting Werkzeug>=0.15
                Downloading Werkzeug-1.0.0-py2.py3-none-any.whl (298 kB)
                    |████████████████████████████████| 298 kB 402 kB/s
            Collecting click>=5.1
                Downloading click-7.1.1-py2.py3-none-any.whl (82 kB)
                    |████████████████████████████████| 82 kB 558 kB/s
            Collecting MarkupSafe>=0.23
            Downloading MarkupSafe-1.1.1-cp36-cp36m-manylinux1_x86_64.whl (27 kB)
            Installing collected packages: MarkupSafe, Jinja2, itsdangerous, Werkzeug, click, flask
            Successfully installed Jinja2-2.11.1 MarkupSafe-1.1.1 Werkzeug-1.0.0 click-7.1.1 flask-1.1.1 itsdangerous-1.1.0


